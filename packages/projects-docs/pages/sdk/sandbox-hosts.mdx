---
title: Host Privacy 
description: Learn about private hosts in CodeSandbox SDK.
---

import { Callout } from 'nextra-theme-docs'

# Hosts

<Callout type="warning" emoji="⚡">
**Best practices**

Use private sandboxes with host tokens for secure access control. Store a single host token with your sandbox details in your database for efficient token management. Consider proxying requests to previews through your own server to maintain lifecycle control and implement custom authentication or routing logic.

- **Use private sandboxes** - Set `privacy: 'private'` for secure sandbox environments
- **Store host tokens in your database** - Persist one host token per sandbox alongside other sandbox metadata
- **Proxy through your server** - Route preview requests through your backend for lifecycle management and custom logic
- **Avoid token proliferation** - Don't create multiple tokens per sandbox unless specifically needed for different access levels
- **Implement custom routing** - Use proxy endpoints to handle wake-up logic and user authentication
</Callout>

CodeSandbox SDK supports different privacy levels for sandboxes and their hosts. Understanding these privacy levels helps you control access to your sandbox environments.

## Port Access

All ports on sandboxes are exposed on URLs following this pattern:
- **HTTP/HTTPS**: `https://$SANDBOX_ID-$PORT.csb.app`  
- **WebSocket**: `ws://$SANDBOX_ID-$PORT.csb.app`

For example, if your sandbox ID is `abc123` and your dev server runs on port `3000`, it would be accessible at `https://abc123-3000.csb.app`.

## Privacy Levels

- **`public`** - Sandbox and its hosts are publicly accessible to anyone
- **`unlisted`** ⚠️ **(deprecated)** - Use `public` or `public-hosts` instead  
- **`private`** - Sandbox is private and hosts require authentication via host tokens
- **`public-hosts`** - Sandbox is private but hosts are publicly accessible without tokens

## Private Hosts

If a sandbox has `private` privacy, its hosts won't be accessible unless a host token is provided.

You can obtain a host token by calling `sdk.hosts.createToken`. This token will by default never expire. It is recommended to persist this token and provide it in dedicated Sandbox sessions.

## Public Hosts for Private Sandboxes

The new `public-hosts` privacy setting allows you to create private sandboxes where the hosts (preview URLs) remain publicly accessible. This is useful when you want:

- Private sandbox content and source code
- Public preview URLs for sharing demos or prototypes
- No authentication required for accessing the running application

```ts
const sandbox = await sdk.sandboxes.create({
  privacy: 'public-hosts', // Private sandbox with public hosts
  // ... other options
});

// Hosts are accessible without tokens
const previewUrl = `https://${sandbox.id}-3000.csb.app`;
```

You create signed urls to your Sandboxes using the `hosts` API on the server:

```ts
const hostToken = await sdk.hosts.createToken('sandbox-id')
```

This gives you low level management of your Sandboxes hosts. But you can also pass the host token to a session. This is especially useful if you want to generate urls based on the state of the Sandbox, generating them in browser sessions etc.

```ts
const sandbox = await sdk.sandboxes.create()
const hostToken = await sdk.hosts.createToken(sandbox.id)
const session = await sandbox.createSession({
  id: 'some-user-reference',
  hostToken
})
```

<Callout>
When you open a signed URL in the browser, we will automatically put the preview token in a
cookie so subsequent requests from the same browser don't require the token.
</Callout>

## Token expiration

You can set an expiration on the preview token when creating it:

```ts
const hostToken = await sdk.hosts.createToken('sandbox-id', {
  expiresAt: new Date(Date.now() + 60 * 60 * 1000) // 1 hour
})
```

This is useful if you want to limit the lifetime of a host token. For example when a user shared a preview of their app with someone who should only have access for a limited time.

## Custom Domains

You can implement custom domains and routing by proxying requests through your own server. This allows you to create user-friendly URLs that map to your sandbox hosts while maintaining control over access and lifecycle management.

Here's a simple example using Express.js to route subdomain requests to sandbox hosts:

```js
const express = require('express');
const jwt = require('jsonwebtoken');
const { createProxyMiddleware } = require('http-proxy-middleware');
const { CodeSandbox } = require('@codesandbox/sdk');

const app = express();
const sdk = new CodeSandbox();
const JWT_SECRET = process.env.JWT_SECRET;

// Middleware to extract project ID from subdomain
app.use(async (req, res, next) => {
  const subdomain = req.hostname.split('.')[0];
  
  // Skip if it's the main domain
  if (subdomain === 'yourdomain' || subdomain === 'www') {
    return next();
  }
  
  // Check if this is a request for HTML content based on Accept header
  const isHtmlRequest = req.headers.accept?.includes('text/html');
  
  try {
    // Check for existing JWT token in cookies
    const token = req.cookies?.projectAuth;
    let projectData = null;
    
    if (token) {
      try {
        // Verify and decode JWT
        projectData = jwt.verify(token, JWT_SECRET);
        
        // Ensure the token matches this subdomain project
        if (projectData.projectId !== subdomain) {
          projectData = null;
        }
      } catch (err) {
        // Token invalid, will fetch from database
        projectData = null;
      }
    }
    
    // If no valid JWT, fetch from database and create new token
    if (!projectData) {
      const project = await getProjectFromDatabase(subdomain);
      
      if (!project || !project.sandboxId) {
        return res.status(404).send('Project not found');
      }
      
      // Ensure user has access (implement your auth logic)
      const userId = req.user?.id;
      if (userId && !await userHasAccessToProject(userId, project.id)) {
        return res.status(403).send('Access denied');
      }
      
      // Create JWT with project and auth info
      projectData = {
        projectId: subdomain,
        sandboxId: project.sandboxId,
        userId: userId,
        status: project.status,
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + (60 * 60) // 1 hour expiry
      };
      
      const newToken = jwt.sign(projectData, JWT_SECRET);
      
      // Set JWT cookie
      res.cookie('projectAuth', newToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        maxAge: 60 * 60 * 1000 // 1 hour
      });
    }
    
    // Only resume sandbox if it's not running and it's an HTML request
    if (isHtmlRequest && projectData.status !== 'running') {
      await sdk.sandboxes.resume(projectData.sandboxId);
      // Update project status in your database
      await updateProjectStatus(projectData.projectId, 'running');
    }
    
    // Create proxy to sandbox host (assuming port 3000 for dev server)
    const targetUrl = `https://${projectData.sandboxId}-3000.csb.app`;
    
    const proxy = createProxyMiddleware({
      target: targetUrl,
      changeOrigin: true,
      ws: true, // Enable WebSocket proxying
      onError: (err, req, res) => {
        console.error('Proxy error:', err);
        res.status(500).send('Sandbox unavailable');
      }
    });
    
    return proxy(req, res, next);
    
  } catch (error) {
    console.error('Error handling subdomain request:', error);
    res.status(500).send('Internal server error');
  }
});

app.listen(3000, () => {
  console.log('Custom domain server running on port 3000');
});
```

This implementation allows users to access their projects via clean URLs like:
- `https://my-project.yourdomain.com` instead of `https://abc123-3000.csb.app`
- `wss://my-project.yourdomain.com` for WebSocket connections

The server automatically handles sandbox wake-up, authentication, and proxying to the appropriate sandbox host.

## Managing Host Tokens (CLI)

The CLI allows you to manage host tokens of a sandbox. You can use it to list, revoke and update host tokens.

### List

```
$ csb sandbox host-tokens :sandbox-id list
 ID                           PREFIX        LAST USED   EXPIRES
 prv_Hca52PUyFHVJsGkciXXbEq   prv_v1_8uKY   Never       Never
 prv_HbE8wC6veXWwcazFYrdUfy   prv_v1__ki7   Never       Never
 prv_MWMhMjbQiY3jSagfaG6D7R   prv_v1_i7iI   Never       Never
```

### Revoke

```
$ csb sandbox host-tokens :sandbox-id revoke prv_Hca52PUyFHVJsGkciXXbEq
```

If you want to revoke all host tokens for a sandbox, you can do so with:

```
$ csb sandbox host-tokens :sandbox-id revoke --all
```

### Update

Extend or shorten the expiration time of a host token:

```
$ csb sandbox host-tokens :sandbox-id update prv_Hca52PUyFHVJsGkciXXbEq --expires-at 2025-03-01
```
