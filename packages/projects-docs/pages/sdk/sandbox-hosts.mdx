---
title: Host Privacy 
description: Learn about private hosts in CodeSandbox SDK.
---

import { Callout } from 'nextra-theme-docs'

# Hosts

<Callout type="warning" emoji="âš¡">
**Best practices**

- **Use private sandboxes** - Set privacy 'private'` for secure sandbox hosts
- **Persist host tokens** - Persist one host token per sandbox alongside other sandbox metadata
- **Proxy through your server** - Route preview requests through your backend for lifecycle management and custom logic

</Callout>

## Port Access

All ports on sandboxes are exposed on URLs following this pattern:

- **HTTP/HTTPS**: `https://$SANDBOX_ID-$PORT.csb.app`
- **WebSocket**: `ws://$SANDBOX_ID-$PORT.csb.app`

For example, if your sandbox ID is `abc123` and your dev server runs on port `3000`, it would be accessible at `https://abc123-3000.csb.app`.

## Private Sandboxes

When you have `private` Sandboxes the hosts can not be accessed by default. You will need to generate a token to access the hosts. You create signed urls to your Sandboxes using the `hosts` API on the server:

```ts
const hostToken = await sdk.hosts.createToken('sandbox-id')
```

This gives you low level management of your Sandboxes hosts. You can pass the host token when connecting to the Sandbox, either on the server or in one of the clients. This is useful as any generated urls from the SDK will include the token:

```ts
const sandbox = await sdk.sandboxes.create('some-template-id')
const hostToken = await sdk.hosts.createToken(sandbox.id)

// Signed URL
const url = sdk.hosts.getUrl(hostToken, 5173)

// Or create a session for the browser/node clients
const session = await sandbox.createSession({
  hostToken
})

// In the browser you will get signed URLs
const url = client.hosts.getUrl(5173)
```

<Callout>
When you open a signed URL in the browser, we will automatically put the preview token in a
cookie so subsequent requests from the same browser don't require the token.
</Callout>

## Token expiration

You can set an expiration on the preview token when creating it:

```ts
const hostToken = await sdk.hosts.createToken('sandbox-id', {
  expiresAt: new Date(Date.now() + 60 * 60 * 1000) // 1 hour
})
```

This is useful if you want to limit the lifetime of a host token. For example when a user shared a preview of their app with someone who should only have access for a limited time.

## Custom Domains

You can implement custom domains and routing by proxying requests through your own server. This allows you to create user-friendly URLs that map to your sandbox hosts while maintaining control over access and lifecycle management.

Here's a simple example using Express.js to route subdomain requests to sandbox hosts:

```js
const express = require('express');
const jwt = require('jsonwebtoken');
const { createProxyMiddleware } = require('http-proxy-middleware');
const { CodeSandbox } = require('@codesandbox/sdk');

const app = express();
const sdk = new CodeSandbox();
const JWT_SECRET = process.env.JWT_SECRET;

// Middleware to extract project ID from subdomain
app.use(async (req, res, next) => {
  const subdomain = req.hostname.split('.')[0];

  // Skip if it's the main domain
  if (subdomain === 'yourdomain' || subdomain === 'www') {
    return next();
  }

  // Check if this is a request for HTML content based on Accept header
  const isHtmlRequest = req.headers.accept?.includes('text/html');

  try {
    // Check for existing JWT token in cookies
    const token = req.cookies?.projectAuth;
    let projectData = null;

    if (token) {
      try {
        // Verify and decode JWT
        projectData = jwt.verify(token, JWT_SECRET);

        // Ensure the token matches this subdomain project
        if (projectData.projectId !== subdomain) {
          projectData = null;
        }
      } catch (err) {
        // Token invalid, will fetch from database
        projectData = null;
      }
    }

    // If no valid JWT, fetch from database and create new token
    if (!projectData) {
      const project = await getProjectFromDatabase(subdomain);

      if (!project || !project.sandboxId) {
        return res.status(404).send('Project not found');
      }

      // Ensure user has access (implement your auth logic)
      const userId = req.user?.id;
      if (userId && !await userHasAccessToProject(userId, project.id)) {
        return res.status(403).send('Access denied');
      }

      // Create JWT with project and auth info
      projectData = {
        projectId: subdomain,
        sandboxId: project.sandboxId,
        userId: userId,
        status: project.status,
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + (60 * 60) // 1 hour expiry
      };

      const newToken = jwt.sign(projectData, JWT_SECRET);

      // Set JWT cookie
      res.cookie('projectAuth', newToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        maxAge: 60 * 60 * 1000 // 1 hour
      });
    }

    // Only resume sandbox if it's not running and it's an HTML request
    if (isHtmlRequest && projectData.status !== 'running') {
      await sdk.sandboxes.resume(projectData.sandboxId);
      // Update project status in your database
      await updateProjectStatus(projectData.projectId, 'running');
    }

    // Create proxy to sandbox host (assuming port 3000 for dev server)
    const targetUrl = `https://${projectData.sandboxId}-3000.csb.app`;

    const proxy = createProxyMiddleware({
      target: targetUrl,
      changeOrigin: true,
      ws: true, // Enable WebSocket proxying
      onError: (err, req, res) => {
        console.error('Proxy error:', err);
        res.status(500).send('Sandbox unavailable');
      }
    });

    return proxy(req, res, next);

  } catch (error) {
    console.error('Error handling subdomain request:', error);
    res.status(500).send('Internal server error');
  }
});

app.listen(3000, () => {
  console.log('Custom domain server running on port 3000');
});
```

This implementation allows users to access their projects via clean URLs like:

- `https://my-project.yourdomain.com` instead of `https://abc123-3000.csb.app`
- `wss://my-project.yourdomain.com` for WebSocket connections

The server automatically handles sandbox wake-up, authentication, and proxying to the appropriate sandbox host.

## Managing Host Tokens (CLI)

The CLI allows you to manage host tokens of a sandbox. You can use it to list, revoke and update host tokens.

### List

```
$ csb sandbox host-tokens :sandbox-id list
 ID                           PREFIX        LAST USED   EXPIRES
 prv_Hca52PUyFHVJsGkciXXbEq   prv_v1_8uKY   Never       Never
 prv_HbE8wC6veXWwcazFYrdUfy   prv_v1__ki7   Never       Never
 prv_MWMhMjbQiY3jSagfaG6D7R   prv_v1_i7iI   Never       Never
```

### Revoke

```
$ csb sandbox host-tokens :sandbox-id revoke prv_Hca52PUyFHVJsGkciXXbEq
```

If you want to revoke all host tokens for a sandbox, you can do so with:

```
$ csb sandbox host-tokens :sandbox-id revoke --all
```

### Update

Extend or shorten the expiration time of a host token:

```
$ csb sandbox host-tokens :sandbox-id update prv_Hca52PUyFHVJsGkciXXbEq --expires-at 2025-03-01
```
