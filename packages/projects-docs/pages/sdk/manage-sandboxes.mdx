---
title: Manage Sandbox Lifecycles
description: Learn how to manage sandbox lifecycles and get information about your sandboxes with the CodeSandbox SDK.
---

import { Callout } from 'nextra-theme-docs'

# Manage Sandbox Lifecycles

The CodeSandbox SDK provides several methods to retrieve information about your sandboxes and manage their lifecycles effectively.

<Callout type="warning" emoji="âš¡">
**Best practices**

- **Create from templates** - Always use custom templates built with the CLI for predictable, fast sandbox creation
- **Track lifecycle in your database** - Store sandbox IDs, lifecycle states, and metadata in your own persistence layer
- **Control lifecycles explicitly** - Don't rely on automatic hibernation or resumes; actively hibernate sandboxes when sessions are done and actively resume them when you want to continue
- **Delete sandboxes after 2 days** - Create a "dorment" state of user projects and delete the related Sandbox after pushing persistence remotely or to your own persistence layer

</Callout>

## Monitoring Sandboxes

You should use your own persistence layer to track VM sessions and sandbox lifecycle states. The following monitoring methods are designed to get additional information about a sandbox and its current running state, not as your primary source of truth for lifecycle management.

Use these methods for:

- **Validation** - Cross-check your internal state against actual sandbox status
- **Administrative features** - Build dashboards and debugging tools
- **Runtime information** - Get current resource usage and activity data
- **Troubleshooting** - Investigate sandbox issues or unexpected states

### Get Sandbox Information

To efficiently retrieve metadata for a specific sandbox without listing all sandboxes, use the `get()` method:

```ts
const sandboxInfo = await sdk.sandboxes.get('sandbox-id');
console.log(sandboxInfo.title, sandboxInfo.tags, sandboxInfo.privacy);
```

This method directly retrieves metadata for a specific sandbox ID, avoiding the performance overhead of the list-and-filter pattern. This is particularly useful for organizations with thousands of sandboxes.

The sandbox information includes:

- `id`: Unique sandbox identifier
- `title`: Sandbox display name
- `description`: Sandbox description
- `tags`: Associated tags for organization
- `privacy`: Privacy setting (`public`, `private`, `public-hosts`)
- `path`: Collection folder location
- `vmTier`: Current VM tier
- `createdAt`: Creation timestamp
- `updatedAt`: Last modification timestamp

### List Running Sandboxes

To get information about currently running sandboxes and VM limits, use the `listRunning()` method:

```ts
const runningInfo = await sdk.sandboxes.listRunning();

console.log(`Running VMs: ${runningInfo.concurrentVmCount}/${runningInfo.concurrentVmLimit}`);

runningInfo.vms.forEach(vm => {
  console.log(`Sandbox ${vm.id}:`);
  console.log(`  Last active: ${vm.lastActiveAt}`);
  console.log(`  Session started: ${vm.sessionStartedAt}`);
  if (vm.specs) {
    console.log(`  Specs: ${vm.specs.cpu} CPU, ${vm.specs.memory}MB RAM, ${vm.specs.storage}GB storage`);
  }
});
```

This method provides:

- Current number of running VMs vs. your account limit
- Details about each running VM including activity timestamps
- VM specifications (CPU, memory, storage) for resource monitoring

Each running VM includes:

- `id`: Sandbox identifier
- `lastActiveAt`: Timestamp of last activity
- `sessionStartedAt`: When the current session began
- `specs`: Resource specifications
  - `cpu`: Number of CPU cores
  - `memory`: RAM in megabytes
  - `storage`: Storage in gigabytes

## Hibernation

Hibernation is a key feature of CodeSandbox that allows sandboxes to be paused and resumed efficiently, saving resources while preserving the exact state of your environment.

### How Hibernation Works

When a Sandbox is hibernated, we create and save a snapshot of the underlying Firecracker VM. This snapshot captures:

- File system state
- Memory contents
- Running processes

When a Sandbox resume, we restore the snapshot. This allows you to continue from exactly where you left off.

<Callout type="warning">
When hibenrated without resume for 2 days the Sandbox will be archived. Please read the deletion section for more information on best practices.
</Callout>

### Manual Hibernation

We highly recommend taking full control of the lifecycle by manually hibernating sandboxes. Even though a timeout is easier to implement, you will not be able to optimize cost or create an optimal user experience.

You can manually hibernate a sandbox at any time:

```ts
import { CodeSandbox } from '@codesandbox/sdk'

const sdk = new CodeSandbox();
const sandbox = await sdk.sandboxes.create('some-template-id');

// Do work on the sandbox
const client = await sandbox.connect();
await client.shells.run('echo "Hello World" > hello.txt');

// Manually hibernate the sandbox
await sdk.sandboxes.hibernate(sandbox.id);
```

Creating a snapshot can take between 3-10 seconds. Resuming from a snapshot takes between 0.5-2 seconds.

### Automatic Hibernation

Sandboxes automatically hibernate after a period of inactivity. The timeout can be configured when creating a sandbox:

```ts
const sandbox = await sdk.sandboxes.create('some-template-id', {
    // How quickly the sandbox should hibernate after inactivity.
    // Defaults to 300 seconds for free users, 1800 seconds for
    // pro users. Maximum is 86400 seconds (1 day).
    hibernationTimeoutSeconds: 1800
})
```

## Resuming

How you manage the resume part of the lifecycle depends on your use case. You might have user sessions, agent sessions or maybe sessions bound to accessing a process exposing a host. Regardless you want to `resume` the Sandbox when the session starts and `hibernate` when the sessions ends.

### Example: From User Session

```ts
// When user starts a session, resume their sandbox
async function startUserSession(userId: string) {
  const user = await getUserFromDatabase(userId);

  if (user.sandboxId) {
    // Resume existing sandbox
    const sandbox = await sdk.sandboxes.resume(user.sandboxId);
    await updateUserSession(userId, { sandboxId: sandbox.id, status: 'active' });
    return sandbox;
  }

  // Create new sandbox if none exists
  const sandbox = await sdk.sandboxes.create('your-template-id');
  await updateUserSession(userId, { sandboxId: sandbox.id, status: 'active' });
  return sandbox;
}

// When user session ends, hibernate their sandbox
async function endUserSession(userId: string) {
  const user = await getUserFromDatabase(userId);

  if (user.sandboxId) {
    await sdk.sandboxes.hibernate(user.sandboxId);
    await updateUserSession(userId, { status: 'hibernated' });
  }
}
```

### Example: From Host Access

If you want direct host access to wake up sandboxes, you need to implement a proxy endpoint that manages this:

```ts
// Proxy endpoint that handles wake-up logic for user projects
app.get('/project/:projectId/*', async (req, res) => {
  const { projectId } = req.params;
  const project = await getProjectFromDatabase(projectId);

  // Ensure user has access to this project
  const userId = req.user.id; // from authentication middleware
  if (!await userHasAccessToProject(userId, projectId)) {
    return res.status(403).send('Access denied');
  }

  // Ensure sandbox is running before proxying
  if (project.sandboxId) {
    await sdk.sandboxes.resume(project.sandboxId);

    // Get the actual host URL
    const hostUrl = `https://${project.sandboxId}-5173.csb.app`

    // Proxy the request to the running sandbox
    const targetPath = req.params[0];
    return res.redirect(`${hostUrl}/${targetPath}`);
  }

  res.status(404).send('Project sandbox not found');
});
```

This approach gives you:

- **Control over wake-up behavior** - Decide when and how sandboxes should resume
- **User session tracking** - Know exactly which sandboxes belong to which users
- **Automatic hibernation** - Enforce hibernation when user sessions end
- **Transparent access** - Users can access their sandbox through a consistent URL

<Callout>
Read more about hosts and proxying requests in [Hosts](./sandbox-hosts)
</Callout>

## Deleting Sandboxes

After 2 days of inactivity we will `archive` your Sandbox. That means a `resume` will take up to 60 seconds. To avoid this you should rather `delete` the Sandbox after 2 days of inactivity. Make sure you push any changes to a remote or to your own persistence before deleting.

If the user comes back a new sandbox should be created and their persistence should be pulled back into the Sandbox. This results in a much faster `resume` and you prevent future costs for persistence.

```ts
// Delete a sandbox when it's no longer needed
await sdk.sandboxes.delete('sandbox-id');
```

### Example: Clean Up Old Sandboxes

```ts
// Clean up sandboxes that haven't been active for a specified period
async function cleanupOldSandboxes(daysInactive = 2) {
  const cutoffDate = new Date(Date.now() - (daysInactive * 24 * 60 * 60 * 1000));

  // Get sandboxes that haven't been active recently
  const oldSandboxes = await getInactiveSandboxesSince(cutoffDate);

  for (const sandbox of oldSandboxes) {
    try {
      // Connect to the sandbox to push changes
      const resumedSandbox = await sdk.sandboxes.resume(sandbox.id);
      const client = await resumedSandbox.connect();

      // Push any uncommitted changes to remote repository
      await client.commands.run([
        'git add -A',
        'git commit -m "Auto-save before cleanup" || true',
        'git push origin main || true'
      ]);

      // Delete the sandbox from CodeSandbox
      await sdk.sandboxes.delete(sandbox.id);

      // Remove from your database
      await deleteSandboxRecord(sandbox.id);

      console.log(`Deleted inactive sandbox ${sandbox.id}`);
    } catch (error) {
      console.error(`Failed to delete sandbox ${sandbox.id}:`, error);
    }
  }
}

// Create a new sandbox and restore remote changes
async function recoverSandboxForUser(userId: string, projectId: string) {
  const project = await getProjectFromDatabase(projectId);

  try {
    // Create new sandbox from template
    const sandbox = await sdk.sandboxes.create(project.templateId);
    const client = await sandbox.connect();

    // Pull remote changes if repository URL exists
    if (project.repositoryUrl) {
      await client.commands.run([
        `git remote add origin ${project.repositoryUrl}`,
        'git fetch origin main',
        'git checkout main || git checkout -b main origin/main',
        'git pull origin main || true'
      ]);
    }

    // Update database with new sandbox ID
    await updateProjectRecord(projectId, { sandboxId: sandbox.id });

    return sandbox;
  } catch (error) {
    console.error('Failed to create and restore sandbox:', error);
    throw new Error('Failed to create sandbox');
  }
}
```

### Example: User-Initiated Deletion

```ts
// Allow users to delete their own sandboxes
async function deleteUserSandbox(userId: string, sandboxId: string) {
  // Verify user owns this sandbox
  const sandbox = await getSandboxFromDatabase(sandboxId);
  if (sandbox.userId !== userId) {
    throw new Error('Unauthorized to delete this sandbox');
  }

  try {
    // Connect to the sandbox to push changes
    const resumedSandbox = await sdk.sandboxes.resume(sandboxId);
    const client = await resumedSandbox.connect();

    // Push any uncommitted changes to remote repository
    await client.commands.run([
      'git add -A',
      'git commit -m "Save changes before deletion" || true',
      'git push origin main || true'
    ]);

    // Delete from CodeSandbox
    await sdk.sandboxes.delete(sandboxId);

    // Remove from your database
    await deleteSandboxRecord(sandboxId);

    return { success: true, message: 'Sandbox deleted successfully' };
  } catch (error) {
    console.error('Failed to delete sandbox:', error);
    throw new Error('Failed to delete sandbox');
  }
}
```
