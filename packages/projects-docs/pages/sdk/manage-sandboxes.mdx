---
title: Manage Sandbox Lifecycles
description: Learn how to manage sandbox lifecycles and get information about your sandboxes with the CodeSandbox SDK.
---

import { Callout } from 'nextra-theme-docs'

# Manage Sandbox Lifecycles

Use your own persistence layer to track VM sessions and sandbox lifecycle states. This will give you the following benefits:

- A request does not accidentally keep a Sandbox running
- A webhook can be called from a process inside the Sandbox to control lifecycle
- As hibernation is directly called, error management is straight forward
- No **ux** vs **cost** tradeoff
- Latency is reduced as session/db state determines state of Sandbox, preventing unecessary calls to `resume`

<Callout>
To adopt best practices set `hibernationTimeoutSeconds` to `86400` (24 hours) and `automaticWakeupConfig` to `false` when you create Sandboxes.
</Callout>

How you manage the resume/hibernate/delete part of the lifecycle depends on your use case. You might have user sessions, agent sessions or maybe sessions bound to accessing a process exposing a host. Regardless you want to `resume` the Sandbox when the session starts and `hibernate` or `delete` when the sessions ends.

Examples of identifying lifecycles:

- **User opens a project**: Resume the related Sandbox as part of fetching the project data. Hibernate the Sandbox on a timeout after the last interaction with the project.
- **User connection**: Resume the related Sandbox when the user has an active connection to your server (WebSocket, heartbeat, etc.), and hibernate on disconnect.
- **Host request**: Use a proxy to resume the Sandbox on HTTP requests and hibernate on request debounce. Read more in [Hosts](./sandbox-hosts).

## User heartbeat example

In this example we keep track of user activity on the project using a heartbeat. A cleanup job checks Sandboxes not interacted with and hibernates them.

```ts
// POST /api/projects - Create a new project
app.post('/api/projects', async (req, res) => {
  const { userId, projectName } = req.body;

  // Create sandbox from template
  const sandbox = await sdk.sandboxes.create({
    id: 'some-template-id'
  });

  // Save project to database
  const project = await db.projects.create({
    id: generateId(),
    userId,
    name: projectName,
    sandboxId: sandbox.id,
    templateId,
    createdAt: new Date()
  });

  // Create session for immediate use
  const session = await sandbox.createSession();

  // Wait for setup if clean boot
  if (sandbox.bootupType === 'CLEAN') {
    const client = await sandbox.connect();
    const steps = await client.setup.getSteps();

    for (const step of steps) {
      await step.waitUntilComplete();
    }
  }

  res.json({ project, session });
});

// GET /api/projects/:id/session - Resume project and get session
app.get('/api/projects/:id/session', async (req, res) => {
  const { id } = req.params;

  // Get project from database
  const project = await db.projects.findById(id);
  if (!project) {
    return res.status(404).json({ error: 'Project not found' });
  }

  // Resume the sandbox
  const sandbox = await sdk.sandboxes.resume(project.sandboxId);

  // Create new session
  const session = await sandbox.createSession();

  // Update last accessed time
  await db.projects.update(id, { lastAccessedAt: new Date() });

  res.json({ session });
});

// POST /api/projects/:id/heartbeat - Keep project active
app.post('/api/projects/:id/heartbeat', async (req, res) => {
  const { id } = req.params;

  // Update last activity timestamp
  await db.projects.update(id, { lastActivityAt: new Date() });

  res.json({ success: true });
});

// Background job to hibernate inactive projects
setInterval(async () => {
  const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);

  // Find projects inactive for more than 5 minutes
  const inactiveProjects = await db.projects.findWhere({
    lastActivityAt: { lt: fiveMinutesAgo },
    status: 'active'
  });

  for (const project of inactiveProjects) {
    try {
      // Hibernate the sandbox
      await sdk.sandboxes.hibernate(project.sandboxId);

      // Update project status
      await db.projects.update(project.id, {
        status: 'hibernated',
        hibernatedAt: new Date()
      });

      console.log(`Hibernated inactive project ${project.id}`);
    } catch (error) {
      console.error(`Failed to hibernate project ${project.id}:`, error);
    }
  }
}, 60 * 1000); // Check every minute
```

## Managed persistence example

You can choose not to rely on our persistence at all. By using `delete`, instead of `hibernate`, you maintain optimal control of Sandbox resumes.

When you want to stop using the Sandbox, push any changes to your database or Git. Then `delete` the Sandbox. When you want to resume, `create` a new Sandbox from the template and pull data back from your database or Git.

```ts
// POST /api/projects - Create project with git initialization
app.post('/api/projects', async (req, res) => {
  const { userId, projectName, repositoryUrl } = req.body;

  // Create sandbox from template
  const sandbox = await sdk.sandboxes.create({
    id: 'some-template-id'
  });

  const client = await sandbox.connect();

  // Initialize Git remote
  await client.commands.run([
    `git remote remove origin`
    `git remote add origin ${repositoryUrl}`
    'git push -u origin main'
  ]);

  client.dispose()

  // Save project to database
  const project = await db.projects.create({
    id: generateId(),
    userId,
    name: projectName,
    sandboxId: sandbox.id,
    repositoryUrl,
    status: 'active',
    lastActivityAt: new Date(),
    createdAt: new Date()
  });

  const session = await sandbox.createSession();
  res.json({ project, session });
});

// GET /api/projects/:id/session - Resume or recreate project
app.get('/api/projects/:id/session', async (req, res) => {
  const { id } = req.params;

  const project = await db.projects.findById(id);

  if (!project) {
    return res.status(404).json({ error: 'Project not found' });
  }

  let sandbox;
  let session;

  try {
    // Try to resume existing sandbox
    sandbox = await sdk.sandboxes.resume(project.sandboxId);
    session = await sandbox.createSession();
  } catch (error) {
    // Sandbox not available, create new one
    console.log(`Sandbox ${project.sandboxId} not available, creating new one`);

    sandbox = await sdk.sandboxes.create({
      id: 'some-template-id'
    });

    const client = await sandbox.connect();

    // Initialize Git remote and pull
    await client.commands.run([
      `git remote remove origin`
      `git remote add origin ${repositoryUrl}`
      'git fetch origin main',
      'git pull origin main'
    ]);

    // Update database with new sandbox ID
    await db.projects.update(id, {
      sandboxId: sandbox.id,
      status: 'active'
    });

    session = await sandbox.createSession();
  }

  // Update last activity
  await db.projects.update(id, { lastActivityAt: new Date() });

  res.json({ session });
});

// POST /api/projects/:id/heartbeat - Keep project active
app.post('/api/projects/:id/heartbeat', async (req, res) => {
  const { id } = req.params;

  await db.projects.update(id, { lastActivityAt: new Date() });
  res.json({ success: true });
});

// Background job to delete inactive projects after Git push
setInterval(async () => {
  const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);

  const inactiveProjects = await db.projects.findWhere({
    lastActivityAt: { lt: fiveMinutesAgo },
    status: 'active'
  });

  for (const project of inactiveProjects) {
    try {
      // Resume sandbox to push changes
      const sandbox = await sdk.sandboxes.resume(project.sandboxId);
      const client = await sandbox.connect();

      // Push any uncommitted changes to Git
      await client.commands.run([
        'git add -A',
        'git commit -m "Auto-save before cleanup" || true',
        'git push origin main'
      ]);

      // Delete the sandbox
      await sdk.sandboxes.delete(project.sandboxId);

      console.log(`Deleted sandbox on project ${project.id} after git push`);
    } catch (error) {
      console.error(`Failed to cleanup project ${project.id}:`, error);
    }
  }
}, 60 * 1000); // Check every minute
```

## Ephemeral branches example

In this example we show how you can keep a hibernated Sandbox as the "main branch" of a project. Where you will generate new branches to preview or create AI suggestions.

```ts
// POST /api/projects - Create project with permanent hibernated sandbox
app.post('/api/projects', async (req, res) => {
  const { userId, projectName } = req.body;

  // Create main project sandbox (always hibernated when not in use)
  const projectSandbox = await sdk.sandboxes.create({
    id: 'some-template-id'
  });

  // Hibernate the main project sandbox
  await sdk.sandboxes.hibernate(projectSandbox.id);

  // Save project to database
  const project = await db.projects.create({
    id: generateId(),
    userId,
    name: projectName,
    mainSandboxId: projectSandbox.id, // Hibernated project sandbox
    status: 'hibernated',
    createdAt: new Date()
  });

  res.json({ project });
});

// POST /api/projects/:id/branches - Create branch sandbox
app.post('/api/projects/:id/branches', async (req, res) => {
  const { id } = req.params;
  const { branchName } = req.body;

  const project = await db.projects.findById(id);

  if (!project) {
    return res.status(404).json({ error: 'Project not found' });
  }

  // Create branch sandbox
  const branchSandbox = await sdk.sandboxes.create({
    id: project.mainSandboxId
  });

  // Save branch to database
  const branch = await db.branches.create({
    id: generateId(),
    projectId: id,
    name: branchName,
    sandboxId: branchSandbox.id,
    status: 'active',
    createdAt: new Date()
  });

  const session = await branchSandbox.createSession();

  res.json({ branch, session });
});


// POST /api/projects/:id/branches/:branchId/promote - Make branch the new main
app.post('/api/projects/:id/branches/:branchId/promote', async (req, res) => {
  const { id, branchId } = req.params;

  const project = await db.projects.findById(id);
  const branch = await db.branches.findById(branchId);

  if (!project || !branch || branch.projectId !== id) {
    return res.status(404).json({ error: 'Project or branch not found' });
  }

  // Hibernate the branch sandbox (it becomes the new main)
  await sdk.sandboxes.hibernate(branch.sandboxId);

  // Update project with new main sandbox
  await db.projects.update(id, {
    mainSandboxId: branch.sandboxId
  });

  const otherBranches = await db.branches.findWhere({
    projectId: id,
    status: 'active'
  });

  // Clean up other branches
  for (const otherBranch of otherBranches) {
    try {
      await sdk.sandboxes.delete(otherBranch.sandboxId);
      await db.branches.update(otherBranch.id, { status: 'deleted' });
    } catch (error) {
      console.error(`Failed to delete branch ${otherBranch.id}:`, error);
    }
  }

  res.json({
    success: true,
    message: `Branch ${branch.name} promoted to main`,
    newMainSandboxId: branch.sandboxId
  });
});
```

## ⚡ Best practices

- **Track lifecycle in your database** - Store sandbox IDs, lifecycle states, and metadata in your own persistence layer.
- **Control lifecycles explicitly** - Don't rely on automatic hibernation or resumes; actively hibernate Sandboxes when sessions are done and actively resume them when you want to continue.
- **Delete Sandboxes** - With custom or long-term persistence, delete Sandboxes to manage cost.
