---
title: Manage Sandbox Lifecycles
description: Learn how to manage sandbox lifecycles and get information about your sandboxes with the CodeSandbox SDK.
---

import { Callout } from 'nextra-theme-docs'

# Manage Sandbox Lifecycles

Use your own persistence layer to track VM sessions and sandbox lifecycle states to provide an optimal user experience with minimal costs. The exact lifecycle management depends on how you approach persistence.

<Callout type="warning">
Even though `hibernationTimeoutSeconds` and `wakeupConfig` are currently provided, we advise against using them as a best practice.
</Callout>

## Default persistence (free)

With default persistence, hibernated Sandboxes are archived after 2–7 days. If your user experience allows resume times of 10–60 seconds, you can rely on `hibernate` and `resume` to only manage the cost of running VMs.

How you manage the resume/hibernate part of the lifecycle depends on your use case. You might have user sessions, agent sessions, or sessions bound to accessing a process exposing a host. Regardless, you should `resume` the Sandbox when the session starts and `hibernate` when the session ends.

- **User opens a project**: Resume the related Sandbox as part of fetching the project data. Hibernate the Sandbox on a timeout after the last interaction with the project.
- **User connection**: Resume the related Sandbox when the user has an active connection to your server (WebSocket, heartbeat, etc.), and hibernate on disconnect.
- **Host request**: Use a proxy to resume the Sandbox on HTTP requests and hibernate on request debounce. Read more in [Hosts](./sandbox-hosts).

```ts
// POST /api/projects - Create a new project
app.post('/api/projects', async (req, res) => {
  const { userId, projectName } = req.body;

  // Create sandbox from template
  const sandbox = await sdk.sandboxes.create({
    id: 'some-template-id'
  });

  // Save project to database
  const project = await db.projects.create({
    id: generateId(),
    userId,
    name: projectName,
    sandboxId: sandbox.id,
    templateId,
    createdAt: new Date()
  });

  // Create session for immediate use
  const session = await sandbox.createSession();

  // Wait for setup if clean boot
  if (sandbox.bootupType === 'CLEAN') {
    const client = await sandbox.connect();
    const steps = await client.setup.getSteps();

    for (const step of steps) {
      await step.waitUntilComplete();
    }
  }

  res.json({ project, session });
});

// GET /api/projects/:id/session - Resume project and get session
app.get('/api/projects/:id/session', async (req, res) => {
  const { id } = req.params;

  // Get project from database
  const project = await db.projects.findById(id);
  if (!project) {
    return res.status(404).json({ error: 'Project not found' });
  }

  // Resume the sandbox
  const sandbox = await sdk.sandboxes.resume(project.sandboxId);

  // Create new session
  const session = await sandbox.createSession();

  // Update last accessed time
  await db.projects.update(id, { lastAccessedAt: new Date() });

  res.json({ session });
});

// POST /api/projects/:id/heartbeat - Keep project active
app.post('/api/projects/:id/heartbeat', async (req, res) => {
  const { id } = req.params;

  // Update last activity timestamp
  await db.projects.update(id, { lastActivityAt: new Date() });

  res.json({ success: true });
});

// Background job to hibernate inactive projects
setInterval(async () => {
  const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);

  // Find projects inactive for more than 5 minutes
  const inactiveProjects = await db.projects.findWhere({
    lastActivityAt: { lt: fiveMinutesAgo },
    status: 'active'
  });

  for (const project of inactiveProjects) {
    try {
      // Hibernate the sandbox
      await sdk.sandboxes.hibernate(project.sandboxId);

      // Update project status
      await db.projects.update(project.id, {
        status: 'hibernated',
        hibernatedAt: new Date()
      });

      console.log(`Hibernated inactive project ${project.id}`);
    } catch (error) {
      console.error(`Failed to hibernate project ${project.id}:`, error);
    }
  }
}, 60 * 1000); // Check every minute
```

## Managed persistence

You can choose not to rely on our persistence at all. By using `delete` instead of `hibernate`, you minimize costs and maintain optimal control of Sandbox resumes.

When you want to stop using the Sandbox, push any changes to your database or Git. Then `delete` the Sandbox. When you want to resume, `create` a new Sandbox from the template and pull data back from your database or Git.

```ts
// POST /api/projects - Create project with git initialization
app.post('/api/projects', async (req, res) => {
  const { userId, projectName, repositoryUrl } = req.body;

  // Create sandbox from template
  const sandbox = await sdk.sandboxes.create({
    id: 'some-template-id'
  });

  const client = await sandbox.connect();

  // Initialize Git remote
  await client.commands.run([
    `git remote remove origin`
    `git remote add origin ${repositoryUrl}`
    'git push -u origin main'
  ]);

  client.dispose()

  // Save project to database
  const project = await db.projects.create({
    id: generateId(),
    userId,
    name: projectName,
    sandboxId: sandbox.id,
    repositoryUrl,
    status: 'active',
    lastActivityAt: new Date(),
    createdAt: new Date()
  });

  const session = await sandbox.createSession();
  res.json({ project, session });
});

// GET /api/projects/:id/session - Resume or recreate project
app.get('/api/projects/:id/session', async (req, res) => {
  const { id } = req.params;

  const project = await db.projects.findById(id);

  if (!project) {
    return res.status(404).json({ error: 'Project not found' });
  }

  let sandbox;
  let session;

  try {
    // Try to resume existing sandbox
    sandbox = await sdk.sandboxes.resume(project.sandboxId);
    session = await sandbox.createSession();
  } catch (error) {
    // Sandbox not available, create new one
    console.log(`Sandbox ${project.sandboxId} not available, creating new one`);

    sandbox = await sdk.sandboxes.create({
      id: 'some-template-id'
    });

    const client = await sandbox.connect();

    // Initialize Git remote and pull
    await client.commands.run([
      `git remote remove origin`
      `git remote add origin ${repositoryUrl}`
      'git fetch origin main',
      'git pull origin main'
    ]);

    // Update database with new sandbox ID
    await db.projects.update(id, {
      sandboxId: sandbox.id,
      status: 'active'
    });

    session = await sandbox.createSession();
  }

  // Update last activity
  await db.projects.update(id, { lastActivityAt: new Date() });

  res.json({ session });
});

// POST /api/projects/:id/heartbeat - Keep project active
app.post('/api/projects/:id/heartbeat', async (req, res) => {
  const { id } = req.params;

  await db.projects.update(id, { lastActivityAt: new Date() });
  res.json({ success: true });
});

// Background job to delete inactive projects after Git push
setInterval(async () => {
  const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);

  const inactiveProjects = await db.projects.findWhere({
    lastActivityAt: { lt: fiveMinutesAgo },
    status: 'active'
  });

  for (const project of inactiveProjects) {
    try {
      // Resume sandbox to push changes
      const sandbox = await sdk.sandboxes.resume(project.sandboxId);
      const client = await sandbox.connect();

      // Push any uncommitted changes to Git
      await client.commands.run([
        'git add -A',
        'git commit -m "Auto-save before cleanup" || true',
        'git push origin main'
      ]);

      // Delete the sandbox
      await sdk.sandboxes.delete(project.sandboxId);

      console.log(`Deleted sandbox on project ${project.id} after git push`);
    } catch (error) {
      console.error(`Failed to cleanup project ${project.id}:`, error);
    }
  }
}, 60 * 1000); // Check every minute
```

## Long-term persistence (coming soon)

With long-term persistence, there is no archiving of hibernated Sandboxes after 2–7 days. That means you will get reliable resumes regardless of the age of the Sandbox.

## ⚡ Best practices

- **Track lifecycle in your database** - Store sandbox IDs, lifecycle states, and metadata in your own persistence layer.
- **Control lifecycles explicitly** - Don't rely on automatic hibernation or resumes; actively hibernate Sandboxes when sessions are done and actively resume them when you want to continue.
- **Delete Sandboxes** - With custom or long-term persistence, delete Sandboxes to manage cost.
