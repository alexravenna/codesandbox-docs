---
title: Manage Sandbox Lifecycles
description: Learn how to manage sandbox lifecycles and get information about your sandboxes with the CodeSandbox SDK.
---

import { Callout } from 'nextra-theme-docs'

# Manage Sandbox Lifecycles

The CodeSandbox SDK provides several methods to retrieve information about your sandboxes and manage their lifecycles effectively.

<Callout type="warning" emoji="âš¡">
**Best practices**

- **Create from templates** - Always use custom templates built with the CLI for predictable, fast sandbox creation
- **Track lifecycle in your database** - Store sandbox IDs, lifecycle states, and metadata in your own persistence layer
- **Control lifecycles explicitly** - Don't rely on automatic hibernation or resumes; actively hibernate sandboxes when sessions are done and actively resume them when you want to continue
- **Delete sandboxes after 2 days** - Create a "dorment" state of user projects and delete the related Sandbox after pushing persistence remotely or to your own persistence layer

</Callout>

## Monitoring Sandboxes

You should use your own persistence layer to track VM sessions and sandbox lifecycle states. The following monitoring methods are designed to get additional information about a sandbox and its current running state, not as your primary source of truth for lifecycle management.

Use these methods for:

- **Validation** - Cross-check your internal state against actual sandbox status
- **Administrative features** - Build dashboards and debugging tools
- **Runtime information** - Get current resource usage and activity data
- **Troubleshooting** - Investigate sandbox issues or unexpected states

### Get Sandbox Information

To efficiently retrieve metadata for a specific sandbox without listing all sandboxes, use the `get()` method:

```ts
const sandboxInfo = await sdk.sandboxes.get('sandbox-id');
console.log(sandboxInfo.title, sandboxInfo.tags, sandboxInfo.privacy);
```

This method directly retrieves metadata for a specific sandbox ID, avoiding the performance overhead of the list-and-filter pattern. This is particularly useful for organizations with thousands of sandboxes.

The sandbox information includes:

- `id`: Unique sandbox identifier
- `title`: Sandbox display name
- `description`: Sandbox description
- `tags`: Associated tags for organization
- `privacy`: Privacy setting (`public`, `private`, `public-hosts`)
- `path`: Collection folder location
- `vmTier`: Current VM tier
- `createdAt`: Creation timestamp
- `updatedAt`: Last modification timestamp

### List Running Sandboxes

To get information about currently running sandboxes and VM limits, use the `listRunning()` method:

```ts
const runningInfo = await sdk.sandboxes.listRunning();

console.log(`Running VMs: ${runningInfo.concurrentVmCount}/${runningInfo.concurrentVmLimit}`);

runningInfo.vms.forEach(vm => {
  console.log(`Sandbox ${vm.id}:`);
  console.log(`  Last active: ${vm.lastActiveAt}`);
  console.log(`  Session started: ${vm.sessionStartedAt}`);
  if (vm.specs) {
    console.log(`  Specs: ${vm.specs.cpu} CPU, ${vm.specs.memory}MB RAM, ${vm.specs.storage}GB storage`);
  }
});
```

This method provides:

- Current number of running VMs vs. your account limit
- Details about each running VM including activity timestamps
- VM specifications (CPU, memory, storage) for resource monitoring

Each running VM includes:

- `id`: Sandbox identifier
- `lastActiveAt`: Timestamp of last activity
- `sessionStartedAt`: When the current session began
- `specs`: Resource specifications
  - `cpu`: Number of CPU cores
  - `memory`: RAM in megabytes
  - `storage`: Storage in gigabytes

## Resume / Hibernate

How you manage the resume/hibernate part of the lifecycle depends on your use case. You might have user sessions, agent sessions or maybe sessions bound to accessing a process exposing a host. Regardless you want to `resume` the Sandbox when the session starts and `hibernate` when the sessions ends.

- **User opens a project**: Resume the related Sandbox as part of fetching the project data. Hibernate the Sandbox on a timeout of last interaction with the project
- **User connection**: Resume the related Sandbox when user has an active connection to your server (WebSocket, heartbeat etc.) and hibernate on disconnect
- **Host request**: Use a proxy to resume the Sandbox on HTML requests and hibernate on request debounce

When a Sandbox is hibernated, we create and save a snapshot of the underlying Firecracker VM. This snapshot captures:

- File system state
- Memory contents
- Running processes

When a Sandbox resume, we restore the snapshot. This allows you to continue from exactly where you left off.

<Callout type="warning">
When hibernated without resume for 2 days the Sandbox will be archived. Please read the deletion section for more information on best practices.
</Callout>

## Deleting Sandboxes

After 2 days of inactivity we will `archive` your Sandbox. That means a `resume` will take up to 60 seconds. To avoid this you should rather `delete` the Sandbox after 2 days of inactivity. Make sure you push any changes to a remote or to your own persistence before deleting.

If the user comes back a new sandbox should be created and their persistence should be pulled back into the Sandbox. This results in a much faster `resume` and you prevent future costs for persistence.

```ts
// Delete a sandbox when it's no longer needed
await sdk.sandboxes.delete('sandbox-id');
```

### Example: Clean Up Old Sandboxes

```ts
// Clean up sandboxes that haven't been active for a specified period
async function cleanupOldSandboxes(daysInactive = 2) {
  const cutoffDate = new Date(Date.now() - (daysInactive * 24 * 60 * 60 * 1000));

  // Get sandboxes that haven't been active recently
  const oldSandboxes = await getInactiveSandboxesSince(cutoffDate);

  for (const sandbox of oldSandboxes) {
    try {
      // Connect to the sandbox to push changes
      const resumedSandbox = await sdk.sandboxes.resume(sandbox.id);
      const client = await resumedSandbox.connect();

      // Push any uncommitted changes to remote repository
      await client.commands.run([
        'git add -A',
        'git commit -m "Auto-save before cleanup" || true',
        'git push origin main || true'
      ]);

      // Delete the sandbox from CodeSandbox
      await sdk.sandboxes.delete(sandbox.id);

      // Remove from your database
      await deleteSandboxRecord(sandbox.id);

      console.log(`Deleted inactive sandbox ${sandbox.id}`);
    } catch (error) {
      console.error(`Failed to delete sandbox ${sandbox.id}:`, error);
    }
  }
}

// Create a new sandbox and restore remote changes
async function recoverSandboxForUser(userId: string, projectId: string) {
  const project = await getProjectFromDatabase(projectId);

  try {
    // Create new sandbox from template
    const sandbox = await sdk.sandboxes.create({
      id: project.templateId
    });
    const client = await sandbox.connect();

    // Pull remote changes if repository URL exists
    if (project.repositoryUrl) {
      await client.commands.run([
        `git remote add origin ${project.repositoryUrl}`,
        'git fetch origin main',
        'git checkout main || git checkout -b main origin/main',
        'git pull origin main || true'
      ]);
    }

    // Update database with new sandbox ID
    await updateProjectRecord(projectId, { sandboxId: sandbox.id });

    return sandbox;
  } catch (error) {
    console.error('Failed to create and restore sandbox:', error);
    throw new Error('Failed to create sandbox');
  }
}
```

### Example: User-Initiated Deletion

```ts
// Allow users to delete their own sandboxes
async function deleteUserSandbox(userId: string, sandboxId: string) {
  // Verify user owns this sandbox
  const sandbox = await getSandboxFromDatabase(sandboxId);
  if (sandbox.userId !== userId) {
    throw new Error('Unauthorized to delete this sandbox');
  }

  try {
    // Connect to the sandbox to push changes
    const resumedSandbox = await sdk.sandboxes.resume(sandboxId);
    const client = await resumedSandbox.connect();

    // Push any uncommitted changes to remote repository
    await client.commands.run([
      'git add -A',
      'git commit -m "Save changes before deletion" || true',
      'git push origin main || true'
    ]);

    // Delete from CodeSandbox
    await sdk.sandboxes.delete(sandboxId);

    // Remove from your database
    await deleteSandboxRecord(sandboxId);

    return { success: true, message: 'Sandbox deleted successfully' };
  } catch (error) {
    console.error('Failed to delete sandbox:', error);
    throw new Error('Failed to delete sandbox');
  }
}
```
