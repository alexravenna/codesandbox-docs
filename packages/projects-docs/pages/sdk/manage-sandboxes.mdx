---
title: Manage Sandbox Lifecycles
description: Learn how to manage sandbox lifecycles and get information about your sandboxes with the CodeSandbox SDK.
---

import { Callout } from 'nextra-theme-docs'

# Manage Sandbox Lifecycles

The CodeSandbox SDK provides several methods to retrieve information about your sandboxes and manage their lifecycles effectively.

<Callout type="warning" emoji="âš¡">
**Best practices**

- **Create from templates** - Always use custom templates built with the CLI for predictable, fast sandbox creation
- **Track lifecycle in your database** - Store sandbox IDs, lifecycle states, and metadata in your own persistence layer
- **Control lifecycles explicitly** - Don't rely on automatic hibernation or resumes; actively hibernate sandboxes when sessions are done and actively resume them when you want to continue

</Callout>

## Monitoring Sandboxes

You should use your own persistence layer to track VM sessions and sandbox lifecycle states. The following monitoring methods are designed to get additional information about a sandbox and its current running state, not as your primary source of truth for lifecycle management.

Use these methods for:

- **Validation** - Cross-check your internal state against actual sandbox status
- **Administrative features** - Build dashboards and debugging tools
- **Runtime information** - Get current resource usage and activity data
- **Troubleshooting** - Investigate sandbox issues or unexpected states

### Get Sandbox Information

To efficiently retrieve metadata for a specific sandbox without listing all sandboxes, use the `get()` method:

```ts
const sandboxInfo = await sdk.sandboxes.get('sandbox-id');
console.log(sandboxInfo.title, sandboxInfo.tags, sandboxInfo.privacy);
```

This method directly retrieves metadata for a specific sandbox ID, avoiding the performance overhead of the list-and-filter pattern. This is particularly useful for organizations with thousands of sandboxes.

The sandbox information includes:

- `id`: Unique sandbox identifier
- `title`: Sandbox display name
- `description`: Sandbox description
- `tags`: Associated tags for organization
- `privacy`: Privacy setting (`public`, `private`, `public-hosts`)
- `path`: Collection folder location
- `vmTier`: Current VM tier
- `createdAt`: Creation timestamp
- `updatedAt`: Last modification timestamp

### List Running Sandboxes

To get information about currently running sandboxes and VM limits, use the `listRunning()` method:

```ts
const runningInfo = await sdk.sandboxes.listRunning();

console.log(`Running VMs: ${runningInfo.concurrentVmCount}/${runningInfo.concurrentVmLimit}`);

runningInfo.vms.forEach(vm => {
  console.log(`Sandbox ${vm.id}:`);
  console.log(`  Last active: ${vm.lastActiveAt}`);
  console.log(`  Session started: ${vm.sessionStartedAt}`);
  if (vm.specs) {
    console.log(`  Specs: ${vm.specs.cpu} CPU, ${vm.specs.memory}MB RAM, ${vm.specs.storage}GB storage`);
  }
});
```

This method provides:

- Current number of running VMs vs. your account limit
- Details about each running VM including activity timestamps
- VM specifications (CPU, memory, storage) for resource monitoring

Each running VM includes:

- `id`: Sandbox identifier
- `lastActiveAt`: Timestamp of last activity
- `sessionStartedAt`: When the current session began
- `specs`: Resource specifications
  - `cpu`: Number of CPU cores
  - `memory`: RAM in megabytes
  - `storage`: Storage in gigabytes

## Hibernation

Hibernation is a key feature of CodeSandbox that allows sandboxes to be paused and resumed efficiently, saving resources while preserving the exact state of your environment.

### How Hibernation Works

When a Sandbox is hibernated, we create and save a snapshot of the underlying Firecracker VM. This snapshot captures:

- File system state
- Memory contents
- Running processes

When a Sandbox resume, we restore the snapshot. This allows you to continue from exactly where you left off.

### Manual Hibernation

We highly recommend taking full control of the lifecycle by manually hibernating sandboxes. Even though a timeout is easier to implement, you will not be able to optimize cost or create an optimal user experience.

You can manually hibernate a sandbox at any time:

```ts
import { CodeSandbox } from '@codesandbox/sdk'

const sdk = new CodeSandbox();
const sandbox = await sdk.sandboxes.create('some-template-id');

// Do work on the sandbox
const client = await sandbox.connect();
await client.shells.run('echo "Hello World" > hello.txt');

// Manually hibernate the sandbox
await sdk.sandboxes.hibernate(sandbox.id);
```

Creating a snapshot can take between 3-10 seconds. Resuming from a snapshot takes between 0.5-2 seconds.

### Automatic Hibernation

Sandboxes automatically hibernate after a period of inactivity. The timeout can be configured when creating a sandbox:

```ts
const sandbox = await sdk.sandboxes.create('some-template-id', {
    // How quickly the sandbox should hibernate after inactivity.
    // Defaults to 300 seconds for free users, 1800 seconds for
    // pro users. Maximum is 86400 seconds (1 day).
    hibernationTimeoutSeconds: 1800
})
```

## Resuming

How you manage the resume part of the lifecycle depends on your use case. You might have user sessions, agent sessions or maybe sessions bound to accessing a process exposing a host. Regardless you want to `resume` the Sandbox when the session starts and `hibernate` when the sessions ends.

### Example: From User Session

```ts
// When user starts a session, resume their sandbox
async function startUserSession(userId: string) {
  const user = await getUserFromDatabase(userId);

  if (user.sandboxId) {
    // Resume existing sandbox
    const sandbox = await sdk.sandboxes.resume(user.sandboxId);
    await updateUserSession(userId, { sandboxId: sandbox.id, status: 'active' });
    return sandbox;
  }

  // Create new sandbox if none exists
  const sandbox = await sdk.sandboxes.create('your-template-id');
  await updateUserSession(userId, { sandboxId: sandbox.id, status: 'active' });
  return sandbox;
}

// When user session ends, hibernate their sandbox
async function endUserSession(userId: string) {
  const user = await getUserFromDatabase(userId);

  if (user.sandboxId) {
    await sdk.sandboxes.hibernate(user.sandboxId);
    await updateUserSession(userId, { status: 'hibernated' });
  }
}
```

### Example: From Host Access

If you want direct host access to wake up sandboxes, you need to implement a proxy endpoint that manages this:

```ts
// Proxy endpoint that handles wake-up logic for user projects
app.get('/project/:projectId/*', async (req, res) => {
  const { projectId } = req.params;
  const project = await getProjectFromDatabase(projectId);

  // Ensure user has access to this project
  const userId = req.user.id; // from authentication middleware
  if (!await userHasAccessToProject(userId, projectId)) {
    return res.status(403).send('Access denied');
  }

  // Ensure sandbox is running before proxying
  if (project.sandboxId) {
    await sdk.sandboxes.resume(project.sandboxId);

    // Get the actual host URL
    const hostUrl = `https://${project.sandboxId}-5173.csb.app`

    // Proxy the request to the running sandbox
    const targetPath = req.params[0];
    return res.redirect(`${hostUrl}/${targetPath}`);
  }

  res.status(404).send('Project sandbox not found');
});
```

This approach gives you:

- **Control over wake-up behavior** - Decide when and how sandboxes should resume
- **User session tracking** - Know exactly which sandboxes belong to which users
- **Automatic hibernation** - Enforce hibernation when user sessions end
- **Transparent access** - Users can access their sandbox through a consistent URL

<Callout>
Read more about hosts and proxying requests in [Hosts](./sandbox-hosts)
</Callout>

### Keeping Snapshots Warm

To avoid sandboxes being archived after 4 days of hibernation (which results in a slower CLEAN bootup), you need to proactively manage hibernated sandboxes by resuming and re-hibernating them before the 4-day limit.

```ts
// Track hibernation times in your database
interface SandboxRecord {
  id: string;
  userId: string;
  hibernatedAt: Date;
  lastWarmedAt?: Date;
}

// Function to warm hibernated sandboxes approaching the 4-day limit
async function warmHibernatedSandboxes() {
  const threeDaysAgo = new Date(Date.now() - (3 * 24 * 60 * 60 * 1000));

  // Find sandboxes hibernated for ~3 days
  const sandboxesToWarm = await getSandboxesHibernatedSince(threeDaysAgo);

  for (const sandbox of sandboxesToWarm) {
    try {
      // Resume the sandbox
      await sdk.sandboxes.resume(sandbox.id);

      // Immediately hibernate it again to create a fresh snapshot
      await sdk.sandboxes.hibernate(sandbox.id);

      // Update your tracking
      await updateSandboxRecord(sandbox.id, {
        hibernatedAt: new Date(),
        lastWarmedAt: new Date()
      });

      console.log(`Warmed sandbox ${sandbox.id}`);
    } catch (error) {
      console.error(`Failed to warm sandbox ${sandbox.id}:`, error);
    }
  }
}

// Run this as a scheduled job (e.g., daily)
// This keeps snapshots warm and extends persistence
```

**Key considerations:**

- **Track hibernation times** - Store when each sandbox was hibernated in your database
- **Run warming jobs** - Schedule regular checks (daily) to warm sandboxes approaching the 4-day limit
- **Monitor costs** - Each resume/hibernate cycle uses VM time, so balance frequency with cost
- **Handle failures** - Some sandboxes might fail to resume; implement proper error handling

This approach prevents the automatic archiving process and maintains fast resume times by avoiding CLEAN state bootups.
