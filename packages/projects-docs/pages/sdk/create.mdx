---
title: Creating Sandboxes
description: Learn how to create sandboxes and templates with the CodeSandbox SDK.
---

import { Callout } from 'nextra-theme-docs'

# Creating Sandboxes

Sandboxes are the main building blocks of the CodeSandbox SDK. Each one represents a single project that you can run, fork, and modify. Every Sandbox is backed by a Firecracker VM, and is completely isolated and persisted. Providing you with a secure environment to run untrusted code.

<Callout type="warning" emoji="âš¡">
**Best practices**

- **Create templates using the CLI** - Don't create templates on codesandbox.io, use the CLI
- **Pre-install dependencies in templates** - Use `setupTasks` to handle installation during template creation
- **Configure tasks properly** - Set up dev servers and processes in your template configuration and avoid using the deprecated _restartOn_ field
- **Avoid excessive live forks** - When creating a Sandbox from a running Sandbox you perform a **Live Fork**. This is slower than forking from a template or hibernated Sandbox
- **Use appropriate VM tiers** - Set the minimum tier needed for your templates and never downsize the tier of a Sandbox created from a template or other Sandboxes

</Callout>

## Templates

Templates are custom, pre-configured environments that allow you to quickly create sandboxes with specific setups, dependencies, and configurations already in place. You must create your own templates using our CLI - this ensures your sandboxes are perfectly tailored to your specific use cases and requirements.

<Callout>
To find inspiration check our template repository on GitHub: https://github.com/codesandbox/sandbox-templates
</Callout>

### Setting up the Template

Create a new folder in your project and add the files you want to have available inside your Sandbox. For example set up a Vite project:

```sh
npx create-vite@latest my-template
```

Now we need to configure the template with tasks so that it will install dependencies and start the dev server. Create a `my-template/.codesandbox/tasks.json` file with the following content:

```json
{
    // Commands that configures the Sandbox after it has started
    "setupTasks": [
        "npm install"
    ],
    // Tasks that can be controlled by the Sandbox Client
    "tasks": {
        "dev-server": {
            "name": "Dev Server",
            "command": "npm run dev",
            // We have automatic port detection, but configuring
            // this will guarantee the port is assigned on the task
            "preview": {
                "port": 5173
            },
            "runAtStart": true
        }
    }
}
```

The `setupTasks` will run after the Sandbox has started, before any other tasks.

<Callout type="warning">
Do **NOT** start dev servers or other long running processes in the `setupTasks`. This will block the setup process and prevent the Sandbox from starting properly.
</Callout>

### Automating tasks

Often you want tasks to automatically run or restart. The `restartOn` field is deprecated in favour of using low level tools that allows you to configure the exact behavior you want. The recommended tools are `nodemon` and `chokidar`. For example you want to restart a dev server whenever the lock file changes:

```json
{
    "setupTasks": ["npm install -g nodemon", "npm install"],
    "tasks": {
        "dev-server": {
            "name": "Dev Server",
            "command": "nodemon --watch \"package-json.lock\" --exec \"npm run dev\"",
            "preview": {
                "port": 5173
            },
            "runAtStart": true
        }
    }
}
```

With `nodemon` the process starts immediately and then restarts whenever the `.lock` file changes. If you rather want to only run a command when a file changes, but not run it initially `chokidar` is a great tool for this:

```json
{
    "setupTasks": ["npm install -g chokidar", "npm install"],
    "tasks": {
        "dev-server": {
            "name": "Dev Server",
            "command": "npm run dev",
            "preview": {
                "port": 5173
            },
            "runAtStart": true
        },
        "install": {
          "name": "Install Deps",
          "command": "chokidar \"package.json\" -c \"npm install\""
        }
    }
}
```

Both of these tools allows configuration like debouncing, delays, logging etc. Giving you full control of the behavior.

<Callout>
Remember that you can always manually manage tasks in your server code. For example if you want to restart the dev server when forking a Sandbox or other explicit flows in your product.
</Callout>

### Building the Template

Now we are ready to deploy the template to our clusters, run:

```bash
$ npx @codesandbox/sdk build ./my-template --ports 5173
```

<Callout>
The template defaults to a `Micro` VM Tier for both building the template and when creating Sandboxes from it. You can not "downsize" Sandboxes when creating them from a template, so make sure you set the minimum tier you want here. Use `build --help` for documentation on all parameters.
</Callout>

This will start the process of creating Sandboxes for each of our clusters, write files, restart, wait for port 5173 to be available and then hibernate. This generates the snapshot that allows you to quickly create Sandboxes already running a dev server from the template.

<Callout>
During template builds, only `.csbignore` files are honored for excluding files. `.gitignore` and `.dockerignore` files will not be used to exclude files from the template. If you need to exclude files during the build process, create a `.csbignore` file in your template directory.
</Callout>

When all clusters are updated successfully you will get a **Template ID** back which you can use when creating your sandboxes:

```ts
const sandbox = await sdk.sandboxes.create('your-template-id-here')
```

### CI Integration

If you run the template builder on **CI** you can pass the `--ci` flag. This removes the interactive "failed sandbox" behavior and rather creates the template id regardless. The Sandbox that errored will show the error.

### Dev Container Configuration

CodeSandbox uses [Dev Containers](https://containers.dev/) for configuring environments. You can use pre-built images or add features to a `.devcontainer/devcontainer.json` file:

```json
{
  "name": "Node.js",
  "image": "mcr.microsoft.com/devcontainers/javascript-node:18",
  "features": {
    "ghcr.io/devcontainers/features/python:1": {}
  }
}
```

In this example, we're installing Node v18 as base, with Python on top using Dev Container Features.

### Custom Docker Images

Create your `.devcontainer/devcontainer.json` file with these contents:

```json
{
  "image": "ubuntu:22.04"
}
```

When we boot the Sandbox, we'll make sure that the docker image is pulled (or built) and we'll make sure that all shells will start within this container. Your `/project/workspace` folder will also be mounted inside the container.

You can decide to build the Docker image as part of the template creation process as well. You can do this by defining this in your `.devcontainer/devcontainer.json`:

```json
{
  "build": {
		"dockerfile": "Dockerfile"
  }
}
```

And creating a `.devcontainer/Dockerfile` with the contents of your Dockerfile.

For more options (like running docker compose, or adding additional features), you can look at the [Dev Container docs](https://containers.dev/implementors/json_reference/).

### Docker Compose Support

You can run additional services using Docker Compose by adding a `docker-compose.yml` configuration to your Dev Container:

```json
{
  "name": "Full Stack App",
  "dockerComposeFile": "docker-compose.yml",
  "service": "app",
  "workspaceFolder": "/workspace"
}
```

With a corresponding `docker-compose.yml`:

```yaml
services:
  app:
    image: mcr.microsoft.com/devcontainers/javascript-node:18
    command: sleep infinity

  db:
    image: postgres:14
    ports:
      - 5432:5432
    environment:
      POSTGRES_PASSWORD: password
```

<Callout>
We will automatically start all services defined in your Docker Compose configuration when the Sandbox starts.
</Callout>

### Setup Tasks vs Dockerfile

When would you configure something in the Dockerfile, and when would you configure something in setup tasks?

As a rule of thumb, if something is configured in relation to the environment (like installing Node, or installing Postgres, or installing Bun), it should go into the Dockerfile. If something is related to the project setup (installing dependencies, building a binary), it should go inside setup tasks.

## Creating a Sandbox

Once you have created a template using the CLI, you can use its template ID to create sandboxes. The template ID is returned when you successfully build a template.

```ts
import { CodeSandbox } from '@codesandbox/sdk'

const sdk = new CodeSandbox();

// Create a sandbox from your custom template
const sandbox = await sdk.sandboxes.create('your-template-id-here');
```

<Callout>
By default Sandboxes are `public-hosts`. Available privacy options:
- `public`: Sandbox and hosts are publicly accessible
- `private`: Sandbox is private, hosts require tokens 
- `public-hosts`: Sandbox is private, but hosts are publicly accessible
</Callout>

```ts
const sandbox = await sdk.sandboxes.create('your-custom-template-id', {
    // Optional properties
    title: 'my-sandbox',
    description: 'My sandbox',
    tags: ['my-tag'],

    // Privacy options: 'public', 'private', or 'public-hosts'
    privacy: 'public-hosts',

    // Collection folder on Dashboard
    path: '/users/some-user-folder',

    // What VM Tier to use for the Sandbox
    vmTier: VMTier.Pico,

    // How quickly the sandbox should hibernate after inactivity.
    // Defaults to 24hours
    hibernationTimeoutSeconds: 86_400,

    // Configure if Sandbox should wake up automatically on HTTP
    // or requests or WebSocket connections
    automaticWakeupConfig: {
        http: false,
        websocket: false
    }
})
```

<Callout>
Even though automatic hibernation and automatic wakeup seems appealing, best practice is to invest in managing lifecycles on your own server. The hibernation timeout and wakeup has opinionated rules that can be good for initial testing, but will add cost and/or negatively impact UX at scale.
</Callout>

Each Sandbox has the following properties, with information about it's own instance:

- `id`: The unique identifier of the sandbox.
- `isUpToDate`: Whether the sandbox is up to date with the latest agent version.
- `cluster`: The cluster the sandbox is running on.
- `bootupType`: The type of bootup, `RUNNING`, `CLEAN`, `RESUME` or `FORK`.

## Workspace

Every sandbox comes with a workspace that provides persistent storage and configuration for your project. The workspace is located at `/project/workspace` and serves as the main working directory for your code and files.

<Callout>
There is also a `/project/sandbox` folder, but consider this deprecated. Use `/project/workspace` for all new projects.
</Callout>

The primary persistence mechanism is based on git with a local remote. This means the workspace is initialized with git automatically.

<Callout type="warning">
Running git commands in the workspace will cause issues with persistence. Please read on to understand how to use git in the Sandbox.
</Callout>

### Using git in the root workspace

```bash
# Remove the default local remote and add your own
git remote remove origin
git remote add origin https://github.com/your-username/your-repo.git

# Now you can push/pull normally
git push -u origin main
```

### Using git as submodule

```bash
# Clone your repository inside the workspace
cd /project/workspace
git clone https://github.com/your-username/your-repo.git my-project
cd my-project

# Work normally within the cloned repository
git add .
git commit -m "Your changes"
git push
```

This approach ensures your work is properly persisted beyond the 4-day hibernation limit and survives sandbox archiving.

## Connect

Establishes a connection to the sandbox and returns a client for interacting with it:

```ts
const sandbox = await sdk.sandboxes.create('your-template-id');
const client = await sandbox.connect();
```

## Create Session

Creates a session you can pass to browser/node clients.

```ts
const sandbox = await sdk.sandboxes.create('your-template-id');
const session = await sandbox.createSession();
```

## Update Tier

Updates the VM tier of the running sandbox:

```ts
import { VMTier } from '@codesandbox/sdk';

const sandbox = await sdk.sandboxes.resume('some-sandbox-id');

// Upgrade to a more powerful VM tier
await sandbox.updateTier(VMTier.Small);
```

<Callout>
You can only upgrade to higher VM tiers, not downgrade.
</Callout>

## Update Hibernation Timeout

Updates the hibernation timeout for the sandbox:

```ts
const sandbox = await sdk.sandboxes.resume('some-sandbox-id');

// Set hibernation timeout to 30 minutes (1800 seconds)
await sandbox.updateHibernationTimeout(1800);
```

The timeout is specified in seconds and determines how long the sandbox will remain active before automatically hibernating due to inactivity.
