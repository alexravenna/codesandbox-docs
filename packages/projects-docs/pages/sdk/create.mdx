---
title: Creating Sandboxes
description: Learn how to create sandboxes and templates with the CodeSandbox SDK.
---

import { Callout } from 'nextra-theme-docs'

# Creating Sandboxes

Sandboxes are the main building blocks of the CodeSandbox SDK. Each one represents a single project that you can run, fork, and modify. Every Sandbox is backed by a Firecracker VM, and is completely isolated and persisted. Providing you with a secure environment to run untrusted code.

<Callout type="warning" emoji="âš¡">
**Best practices**

- **Create templates for your specific use cases** - Don't rely on generic setups
- **Pre-install dependencies in templates** - Use `setupTasks` to handle installation during template creation
- **Configure tasks properly** - Set up dev servers and processes in your template configuration and avoid using the deprecated _restartOn_ field
- **Avoid excessive live forks** - When creating a Sandbox from a running Sandbox you perform a **Live Fork**. This is slower than forking from a template or hiernated Sandbox
- **Use appropriate VM tiers** - Set the minimum tier needed for your templates and never downsize the tier of a Sandbox created from a template or other Sandboxes
  </Callout>

## Templates

Templates are custom, pre-configured environments that allow you to quickly create sandboxes with specific setups, dependencies, and configurations already in place. You must create your own templates using our CLI - this ensures your sandboxes are perfectly tailored to your specific use cases and requirements.

<Callout>
To find inspiration check our template repository on GitHub: https://github.com/codesandbox/sandbox-templates
</Callout>

### Setting up the Template

Create a new folder in your project and add the files you want to have available inside your Sandbox. For example set up a Vite project:

```sh
npx create-vite@latest my-template
```

Now we need to configure the template with tasks so that it will install dependencies and start the dev server. Create a `my-template/.codesandbox/tasks.json` file with the following content:

```json
{
    // Commands that configures the Sandbox after it has started
    "setupTasks": [
        "npm install"
    ],
    // Tasks that can be controlled by the Sandbox Client
    "tasks": {
        "dev-server": {
            "name": "Dev Server",
            "command": "npm run dev",
            // We have automatic port detection, but configuring
            // this will guarantee the port is assigned on the task
            "preview": {
                "port": 5173
            },
            "runAtStart": true
        }
    }
}
```

The `setupTasks` will run after the Sandbox has started, before any other tasks.

<Callout>
Do **NOT** start dev servers or other long running processes in the `setupTasks`. This will block the setup process and prevent the Sandbox from starting properly.
</Callout>

### Building the Template

Now we are ready to deploy the template to our clusters, run:

```bash
$ CSB_API_KEY=your-api-key npx @codesandbox/sdk build ./my-template --privacy private --vm-tier Nano --vm-build-tier Micro --ports 5173
```

<Callout>
The template defaults to a `Micro` VM Tier for both building the template and when creating Sandboxes from it. You can not "downsize" Sandboxes when creating them from a template, so make sure you set the minimum tier you want here. It is recommended to make templates private, but they default to "public". Use `build --help` for documentation on all parameters.
</Callout>

This will start the process of creating Sandboxes for each of our clusters, write files, restart, wait for port 5173 to be available and then hibernate. This generates the snapshot that allows you to quickly create Sandboxes already running a dev server from the template.

When all clusters are updated successfully you will get a "Template ID" back which you can use when creating your sandboxes:

```ts
import { VMTier } from '@codesandbox/sdk'

const sandbox = await sdk.sandboxes.create({
    id: 'your-template-id-here',
    // Defaults to your --vm-tier parameter when building the template. Never
    // insert a lower tier than the build, this would be a harmful downsizing
    vmTier: VMTier.Micro
})
```

### CI Integration

If you run the template builder on **CI** you can pass the `--ci` flag. This removes the interactive "failed sandbox" behavior and rather creates the template id regardless. The Sandbox that errored will show the error.

### Custom Docker Images

CodeSandbox uses [Dev Containers](https://containers.dev/) for configuring Docker or Docker Compose for an environment. You can configure Docker by creating a `.devcontainer/devcontainer.json` file inside your template folder with these contents:

```json
{
  "image": "ubuntu:22.04"
}
```

When we boot the sandbox, we'll make sure that the docker image is pulled (or built) and we'll make sure that all shells will start within this container. Your `/project/workspace` folder will also be mounted inside the container.

You can decide to build the Docker image as part of the template creation process as well. You can do this by defining this in your `.devcontainer/devcontainer.json`:

```json
{
  "build": {
		"dockerfile": "Dockerfile"
  }
}
```

And creating a `.devcontainer/Dockerfile` with the contents of your Dockerfile.

For more options (like running docker compose, or adding additional features), you can look at the [Dev Container docs](https://containers.dev/implementors/json_reference/).

### Dev Container Configuration Examples

You can also use pre-built images or add features to your Dev Container:

```json
{
  "name": "Node.js",
  "image": "mcr.microsoft.com/devcontainers/javascript-node:18",
  "features": {
    "ghcr.io/devcontainers/features/python:1": {}
  }
}
```

In this example, we're installing Node v18 as base, with Python on top using Dev Container Features.

### Docker Compose Support

You can run additional services using Docker Compose by adding a `docker-compose.yml` configuration to your Dev Container:

```json
{
  "name": "Full Stack App",
  "dockerComposeFile": "docker-compose.yml",
  "service": "app",
  "workspaceFolder": "/workspace"
}
```

With a corresponding `docker-compose.yml`:

```yaml
services:
  app:
    image: mcr.microsoft.com/devcontainers/javascript-node:18
    command: sleep infinity

  db:
    image: postgres:14
    ports:
      - 5432:5432
    environment:
      POSTGRES_PASSWORD: password
```

<Callout>
We will automatically start all services defined in your Docker Compose configuration when the Sandbox starts.
</Callout>

### Setup Tasks vs Dockerfile

When would you configure something in the Dockerfile, and when would you configure something in setup tasks?

As a rule of thumb, if something is configured in relation to the environment (like installing Node, or installing Postgres, or installing Bun), it should go into the Dockerfile. If something is related to the project setup (installing dependencies, building a binary), it should go inside setup tasks.

## Creating a Sandbox

Once you have created a template using the CLI, you can use its template ID to create sandboxes. The template ID is returned when you successfully build a template.

```ts
import { CodeSandbox } from '@codesandbox/sdk'

const sdk = new CodeSandbox();

// Create a sandbox from your custom template
const sandbox = await sdk.sandboxes.create({
    // Required: Your custom template ID from the CLI build process
    id: 'your-template-id-here'
});
```

<Callout>
By default Sandboxes are `public` and can be accessed by anyone. Available privacy options:
- `public`: Sandbox and hosts are publicly accessible
- `private`: Sandbox is private, hosts require tokens 
- `public-hosts`: Sandbox is private, but hosts are publicly accessible
- `unlisted`: (deprecated) Use `public` or `public-hosts` instead
</Callout>

<Callout type="warning">
**Warning about Live Forks**: If you use the `id` of a running sandbox to create a new sandbox, it will become a "live fork" which does not scale. It will take longer to fork, and with many forks from the same sandbox, the latency gets higher and higher until you eventually get errors. Always use hibernated sandbox IDs or template IDs for optimal performance.
</Callout>

```ts
const sandbox = await sdk.sandboxes.create({
    // Required: Your custom template ID
    id: 'your-custom-template-id',

    // Optional properties
    title: 'my-sandbox',
    description: 'My sandbox',
    tags: ['my-tag'],

    // Privacy options: 'public', 'private', or 'public-hosts'
    privacy: 'public-hosts',

    // Collection folder on Dashboard
    path: '/users/some-user-folder',

    // Prefer closest cluster. Follows ISO 3166-1 alpha-2 codes.
    ipcountry: "US",

    // What VM Tier to use for the Sandbox
    vmTier: VMTier.Pico,

    // How quickly the sandbox should hibernate after inactivity.
    // Defaults to 300 seconds for free users, 1800 seconds for
    // pro users. Maximum is 86400 seconds (1 day).
    hibernationTimeoutSeconds: 120_000,

    // Configure if Sandbox should wake up automatically on HTTP
    // or requests or WebSocket connections
    automaticWakeupConfig: {
        http: true,
        websocket: true
    }
})
```

<Callout>
The `automaticWakeupConfig` only wakes up the Sandbox, it does not extend its hibernation timeout.
</Callout>

The `sandbox` object represents the instance of a sandbox running in our infrastructure. The methods detailed below require the Sandbox to be running.

Each Sandbox has the following properties, with information about it's own instance:

- `id`: The unique identifier of the sandbox.
- `isUpToDate`: Whether the sandbox is up to date with the latest agent version.
- `cluster`: The cluster the sandbox is running on.
- `bootupType`: The type of bootup, `RUNNING`, `CLEAN`, `RESUME` or `FORK`.

## Workspace

Every sandbox comes with a workspace that provides persistent storage and configuration for your project. The workspace is located at `/project/workspace` and serves as the main working directory for your code and files.

<Callout>
There is also a `/project/sandbox` folder, but consider this deprecated. Use `/project/workspace` for all new projects.
</Callout>

### Git-based Persistence

The primary persistence mechanism is based on git with a local remote. This means the workspace is initialized with git automatically.

<Callout type="warning">
**Warning about Git Commands**: Users should not run git commands in the workspace unless they do one of the following:

1. **Change the remote of the workspace** - Point to their own git repository
2. **Clone a repo as a nested folder** - Work within a cloned repository inside the workspace

Both of these approaches will enable a secondary persistence mechanisms which is not git.

</Callout>

If you want to use Git in a Sandbox, use one of the following approaches:

#### Option 1: Change the Remote

```bash
# Remove the default local remote and add your own
git remote remove origin
git remote add origin https://github.com/your-username/your-repo.git

# Now you can push/pull normally
git push -u origin main
```

#### Option 2: Clone as Nested Folder

```bash
# Clone your repository inside the workspace
cd /project/workspace
git clone https://github.com/your-username/your-repo.git my-project
cd my-project

# Work normally within the cloned repository
git add .
git commit -m "Your changes"
git push
```

This approach ensures your work is properly persisted beyond the 4-day hibernation limit and survives sandbox archiving.

### Configuration Directories

The workspace includes two important configuration directories:

#### `.codesandbox` Directory

The `.codesandbox` directory contains CodeSandbox-specific configuration files that control how your sandbox behaves:

- **`tasks.json`**: Defines setup tasks and runtime tasks for your sandbox
- **Configuration files**: Additional settings for sandbox behavior and environment setup

#### `.devcontainer` Directory

The `.devcontainer` directory contains Development Container configuration files that define your sandbox's Docker environment:

- **`devcontainer.json`**: Main configuration file for the dev container setup
- **`Dockerfile`**: Custom Docker image definitions (when using custom builds)
- **`docker-compose.yml`**: Multi-service configurations for complex setups

These files allow you to customize the underlying container environment, install additional tools, and configure multi-service architectures for your projects.

## Connect

Establishes a connection to the sandbox and returns a client for interacting with it:

```ts
const sandbox = await sdk.sandboxes.create({ id: 'your-template-id' });
const client = await sandbox.connect();
```

## Create Session

Creates a new user session with specific configurations like permissions, git access, and environment variables:

```ts
const sandbox = await sdk.sandboxes.create({ id: 'your-template-id' });
const session = await sandbox.createSession();
```

The session can be passed to the browser or a different Node.js environment to connect directly to the sandbox. This is particularly useful for creating isolated user experiences with specific permissions and configurations.

## Update Tier

Updates the VM tier of the running sandbox:

```ts
import { VMTier } from '@codesandbox/sdk';

const sandbox = await sdk.sandboxes.create({ id: 'your-template-id' });

// Upgrade to a more powerful VM tier
await sandbox.updateTier(VMTier.Small);
```

<Callout>
You can only upgrade to higher VM tiers, not downgrade.
</Callout>

## Update Hibernation Timeout

Updates the hibernation timeout for the sandbox:

```ts
const sandbox = await sdk.sandboxes.create({ id: 'your-template-id' });

// Set hibernation timeout to 30 minutes (1800 seconds)
await sandbox.updateHibernationTimeout(1800);
```

The timeout is specified in seconds and determines how long the sandbox will remain active before automatically hibernating due to inactivity.
