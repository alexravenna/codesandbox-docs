---
title: Creating Sandboxes
description: Learn how to create sandboxes and templates with the CodeSandbox SDK.
---

import { Callout } from 'nextra-theme-docs'

# Creating Sandboxes

Sandboxes are the main building blocks of the CodeSandbox SDK. Each one represents a single project that you can run, fork, and modify. Every Sandbox is backed by a Firecracker VM, and is completely isolated and persisted. Providing you with a secure environment to run untrusted code.

<Callout type="warning" emoji="⚡">
**Best practices**

- **Create templates** - Don't create templates on codesandbox.io, use the CLI
- **Pre-install dependencies in templates** - Use `setupTasks` to handle installation during template creation
- **Configure tasks properly** - Set up dev servers and processes in your template configuration and avoid using the deprecated _restartOn_ field
- **Avoid excessive live forks** - When creating a Sandbox from a running Sandbox you perform a **Live Fork**. This is slower than forking from a template or hibernated Sandbox
- **Use appropriate VM tiers** - Set the minimum tier needed for your templates and never downsize the tier of a Sandbox created from a template or other Sandboxes

</Callout>

## Templates

Templates are custom, pre-configured environments that allow you to quickly create sandboxes with specific setups, dependencies, and configurations already in place. You must create your own templates using our CLI - this ensures your sandboxes are perfectly tailored to your specific use cases and requirements.

<Callout>
To find inspiration check our template repository on GitHub: https://github.com/codesandbox/sandbox-templates
</Callout>

### Setting up the Template

Create a new folder in your project and add the files you want to have available inside your Sandbox. For example set up a Vite project:

```sh
npx create-vite@latest my-template
```

Now we need to configure the template with tasks so that it will install dependencies and start the dev server. Create a `my-template/.codesandbox/tasks.json` file with the following content:

```json
{
    // Commands that configures the Sandbox after it has started
    "setupTasks": [
        "npm install"
    ],
    // Tasks that can be controlled by the Sandbox Client
    "tasks": {
        "dev-server": {
            "name": "Dev Server",
            "command": "npm run dev",
            // We have automatic port detection, but configuring
            // this will guarantee the port is assigned on the task
            "preview": {
                "port": 5173
            },
            "runAtStart": true
        }
    }
}
```

The `setupTasks` will run after the Sandbox has started, before any other tasks.

<Callout type="warning">
Do **NOT** start dev servers or other long running processes in the `setupTasks`. This will block the setup process and prevent the Sandbox from starting properly.
</Callout>

### Automating tasks

Often you want tasks to automatically run or restart. The `restartOn` field is deprecated in favour of using low level tools that allows you to configure the exact behavior you want. The recommended tools are `nodemon` and `chokidar`. For example you want to restart a dev server whenever the lock file changes:

```json
{
    "setupTasks": ["npm install -g nodemon", "npm install"],
    "tasks": {
        "dev-server": {
            "name": "Dev Server",
            "command": "nodemon --watch \"package-json.lock\" --exec \"npm run dev\"",
            "preview": {
                "port": 5173
            },
            "runAtStart": true
        }
    }
}
```

With `nodemon` the process starts immediately and then restarts whenever the `.lock` file changes. If you rather want to only run a command when a file changes, but not run it initially `chokidar` is a great tool for this:

```json
{
    "setupTasks": ["npm install -g chokidar", "npm install"],
    "tasks": {
        "dev-server": {
            "name": "Dev Server",
            "command": "npm run dev",
            "preview": {
                "port": 5173
            },
            "runAtStart": true
        },
        "install": {
          "name": "Install Deps",
          "command": "chokidar \"package.json\" -c \"npm install\""
        }
    }
}
```

Both of these tools allows configuration like debouncing, delays, logging etc. Giving you full control of the behavior.

<Callout>
Remember that you can always manually manage tasks in your server code. For example if you want to restart the dev server when forking a Sandbox or other explicit flows in your product.
</Callout>

### Building the Template

Now we are ready to deploy the template to our clusters, run:

```bash
$ npx @codesandbox/sdk build ./my-template --ports 5173
```

<Callout>
The template defaults to a `Micro` VM Tier for both building the template and when creating Sandboxes from it. You can not "downsize" Sandboxes when creating them from a template, so make sure you set the minimum tier you want here. Use `build --help` for documentation on all parameters.
</Callout>

This will start the process of creating Sandboxes for each of our clusters, write files, restart, wait for port 5173 to be available and then hibernate. This generates the snapshot that allows you to quickly create Sandboxes already running a dev server from the template.

When all clusters are updated successfully you will get a **Template ID** back which you can use when creating your sandboxes:

```ts
const sandbox = await sdk.sandboxes.create({
  id: 'your-template-id-here'
})
```

### CI Integration

If you run the template builder on **CI** you can pass the `--ci` flag. This removes the interactive "failed sandbox" behavior and rather creates the template id regardless. The Sandbox that errored will show the error.

## Docker

By default the template uses a universal image which gives you the most common tools and setup. You can configure your own environment by using docker. You can create your own `.codesandbox/Dockerfile` file to configure the environment, for example:

```Dockerfile
FROM node:latest
WORKDIR /project/workspace
```

### Docker Compose Support

You can run additional services using Docker Compose by adding a `docker-compose.yml` configuration to your template:

```yaml
services:
  app:
    image: mcr.microsoft.com/devcontainers/javascript-node:18
    command: sleep infinity

  db:
    image: postgres:14
    ports:
      - 5432:5432
    environment:
      POSTGRES_PASSWORD: password
```

Make sure you run `docker-compose up` in your `tasks.json` file or manually when creating Sandboxes from the template:

```json
{
  // Runs in the workspace directory
  "setupTasks": ["docker-compose up"]
}
```

### Setup Tasks vs Dockerfile

When would you configure something in the Dockerfile, and when would you configure something in setup tasks?

As a rule of thumb, if something is configured in relation to the environment (like installing Node, or installing Postgres, or installing Bun), it should go into the Dockerfile. If something is related to the project setup (installing dependencies, building a binary), it should go inside setup tasks.

## Creating a Sandbox

Once you have created a template using the CLI, you can use its template ID to create sandboxes. The template ID is returned when you successfully build a template.

```ts
import { CodeSandbox } from '@codesandbox/sdk'

const sdk = new CodeSandbox();

// Create a sandbox from your custom template
const sandbox = await sdk.sandboxes.create({
  id: 'your-template-id-here'
});
```

<Callout>
By default Sandboxes are `public-hosts`. Available privacy options:
- `public`: Sandbox and hosts are publicly accessible
- `private`: Sandbox is private, hosts require tokens 
- `public-hosts`: Sandbox is private, but hosts are publicly accessible
</Callout>

```ts
const sandbox = await sdk.sandboxes.create({
    // The template id
    id: 'your-custom-template-id',

    // Optional properties
    title: 'my-sandbox',
    description: 'My sandbox',
    tags: ['my-tag'],

    // Privacy options: 'public', 'private', or 'public-hosts'
    privacy: 'public-hosts',

    // Collection folder on Dashboard
    path: '/users/some-user-folder',

    // What VM Tier to use for the Sandbox
    vmTier: VMTier.Micro,

    // How quickly the sandbox should hibernate after inactivity. Set
    // this field to the maximum 24 hours (See deprecation below)
    hibernationTimeoutSeconds: 86400,

    // Configure if Sandbox should wake up automatically on HTTP
    // or requests or WebSocket connections. Set both of these to `false`
    // (See deprecation below)
    automaticWakeupConfig: {
        http: false,
        websocket: false
    }
})
```

<Callout type="warning">
Both `hibernationTimeoutSeconds` and `wakeupConfig` has been deprecated. This is because manual lifecycle management is needed to scale, control cost and create a predictable user experience. These two feature will not be available in next major version.
</Callout>

Each Sandbox has the following properties, with information about it's own instance:

- `id`: The unique identifier of the sandbox.
- `isUpToDate`: Whether the sandbox is up to date with the latest agent version.
- `cluster`: The cluster the sandbox is running on.
- `bootupType`: The type of bootup, `RUNNING`, `CLEAN`, `RESUME` or `FORK`.

## Create Template From sandbox

You can use an existing Sandbox id with `create`. Currently this is considered a risky operation

<Callout type="warning" emoji="⚡">
**Best practices**

- **Avoid forking running Sandboxes** - Avoid using the `id` of a running sandbox as this creates a "live fork" which doesn't scale
- **Plan your versioning strategy** - Use git commits, branches, or hibernated Sandbox workflows to manage different versions effectively
- **Hibernate before forking** - Keep stable versions hibernated to serve as reliable fork sources

</Callout>

You can fork a Sandbox by referencing the `id` of an existing Sandbox:

```ts
const sandbox = await sdk.sandboxes.fork('some-sandbox-id', {
  // Override any options
})
```

Forking a hibernated Sandbox will take 1-3 seconds, while forking running Sandboxes will take longer. If you need Sandbox versioning please consider one of the following suggested strategies.

### 1. Git Commits and Checkouts

Use git history to manage different versions within a single Sandbox:

- Make commits for each version milestone
- Use `git checkout` to switch between versions
- Tag important releases for easy reference

### 2. Branch-Based Remote Previews

Push different versions to separate branches to generate previews with external services:

- Create feature branches for different versions
- Push to remote repositories
- Integrate with preview deployment services
- Use branch URLs for sharing specific versions
- When choosing a different preview, checkout that branch for further development

### 3. Hibernated Sandbox Workflow

Maintain a structured approach using hibernated Sandboxes:

- Keep your current stable version as a hibernated Sandbox
- Create forks from the hibernated version for previews
- When ready to release a new version:
  1. Hibernate the new version
  2. Fork from it for additional development
  3. Repeat the cycle for continuous versioning

This approach ensures you always have stable reference points while maintaining the ability to create fast, scalable forks for development and preview purposes.

## Workspace

Every sandbox comes with a workspace that provides persistent storage and configuration for your project. The workspace is located at `/project/workspace` and serves as the main working directory for your code and files.

<Callout>
There is also a `/project/sandbox` folder, but consider this deprecated. Use `/project/workspace` for all new projects.
</Callout>

The primary persistence mechanism is based on git with a local remote. This means the workspace is initialized with git automatically.

<Callout type="warning">
Running git commands in the workspace without setting a new remote will cause issues with persistence.
</Callout>

### Using git in the root workspace

```bash
# Remove the default local remote and add your own
git remote remove origin
git remote add origin https://github.com/your-username/your-repo.git

# Now you can push/pull normally
git push -u origin main
```

### Using git as submodule

```bash
# Clone your repository inside the workspace
cd /project/workspace
git clone https://github.com/your-username/your-repo.git my-project
cd my-project

# Work normally within the cloned repository
git add .
git commit -m "Your changes"
git push
```

This approach ensures your work is properly persisted and archived when necessary.

## Connect

Establishes a connection to the sandbox and returns a client for interacting with it:

```ts
const sandbox = await sdk.sandboxes.create({
  id: 'your-template-id'
});
const client = await sandbox.connect();
```

## Create Session

Creates a session you can pass to browser/node clients.

```ts
const sandbox = await sdk.sandboxes.create({
  id: 'your-template-id'
});
const session = await sandbox.createSession();
```

## Update Tier

Updates the VM tier of the running sandbox:

```ts
import { VMTier } from '@codesandbox/sdk';

const sandbox = await sdk.sandboxes.resume('some-sandbox-id');

// Upgrade to a more powerful VM tier
await sandbox.updateTier(VMTier.Small);
```

<Callout type="warning">
You can only upgrade to higher VM tiers than the initial one.
</Callout>
